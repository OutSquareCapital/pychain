from typing import Any, overload
from collections.abc import Callable, Iterable, Iterator, Mapping, Sequence

def accumulate[T](
    binop: Callable[[T, T], T], seq: Iterable[T], initial: Any = ...
) -> Iterator[T]: ...
def concat[T](seqs: Iterable[Iterable[T]]) -> Iterator[T]: ...
def concatv[T](*seqs: Iterable[T]) -> Iterator[T]: ...
def cons[T](el: T, seq: Iterable[T]) -> Iterator[T]: ...
def count(seq: Iterable[Any]) -> int: ...
def diff[T](*seqs: Iterable[T], **kwargs: Any) -> Iterator[tuple[T, ...]]: ...
def drop[T](n: int, seq: Iterable[T]) -> Iterator[T]: ...
def first[T](seq: Iterable[T]) -> T: ...
def frequencies[T](seq: Iterable[T]) -> dict[T, int]: ...
@overload
def get[KT, VT](ind: KT, seq: Mapping[KT, VT], default: Any = ...) -> VT: ...
@overload
def get[T](ind: int, seq: Sequence[T], default: Any = ...) -> T: ...
@overload
def get[KT, VT](
    ind: Iterable[KT], seq: Mapping[KT, VT], default: Any = ...
) -> Iterator[VT]: ...
@overload
def get[T](ind: Iterable[int], seq: Sequence[T], default: Any = ...) -> Iterator[T]: ...
def groupby[T, KT](key: Callable[[T], KT], seq: Iterable[T]) -> dict[KT, list[T]]: ...
def interleave[T](seqs: Iterable[Iterable[T]]) -> Iterator[T]: ...
def interpose[T](el: Any, seq: Iterable[T]) -> Iterator[T | Any]: ...
def isdistinct[T](seq: Iterable[Any]) -> bool: ...
def isiterable[T](x: Any) -> bool: ...
def iterate[T](func: Callable[[T], T], x: T) -> Iterator[T]: ...
def join[T1, T2, KT](
    leftkey: Callable[[T1], KT],
    leftseq: Iterable[T1],
    rightkey: Callable[[T2], KT],
    rightseq: Iterable[T2],
    left_default: Any = ...,
    right_default: Any = ...,
) -> Iterator[tuple[T1, T2]]: ...
def last[T](seq: Iterable[T]) -> T: ...
def mapcat[T1, T2](
    func: Callable[[Iterable[T1]], Iterable[T2]], seqs: Iterable[Iterable[T1]]
) -> Iterator[T2]: ...
def merge_sorted[T](*seqs: Iterable[T], **kwargs: Any) -> Iterator[T]: ...
def nth[T](n: int, seq: Iterable[T]) -> T: ...
def partition[T](
    n: int, seq: Iterable[T], pad: Any = ...
) -> Iterator[tuple[T, ...]]: ...
def partition_all[T](n: int, seq: Iterable[T]) -> Iterator[tuple[T, ...]]: ...
def peek[T](seq: Iterable[T]) -> tuple[T, Iterator[T]]: ...
def peekn[T](n: int, seq: Iterable[T]) -> tuple[tuple[T, ...], Iterator[T]]: ...
def pluck(ind: Any, seqs: Iterable[Any], default: Any = ...) -> Iterator[Any]: ...
def random_sample[T](
    prob: float, seq: Iterable[T], random_state: Any = ...
) -> Iterator[T]: ...
def reduceby[T, KT, VT](
    key: Callable[[T], KT],
    binop: Callable[[VT, T], VT],
    seq: Iterable[T],
    init: Any = ...,
) -> dict[KT, VT]: ...
def remove[T](predicate: Callable[[T], bool], seq: Iterable[T]) -> Iterator[T]: ...
def second[T](seq: Iterable[T]) -> T: ...
def sliding_window[T](n: int, seq: Iterable[T]) -> Iterator[tuple[T, ...]]: ...
def tail[T](n: int, seq: Iterable[T]) -> Iterator[T]: ...
def take[T](n: int, seq: Iterable[T]) -> Iterator[T]: ...
def take_nth[T](n: int, seq: Iterable[T]) -> Iterator[T]: ...
def topk[T](
    k: int, seq: Iterable[T], key: Callable[[T], Any] | None = ...
) -> tuple[T, ...]: ...
def unique[T](
    seq: Iterable[T], key: Callable[[T], Any] | None = ...
) -> Iterator[T]: ...
