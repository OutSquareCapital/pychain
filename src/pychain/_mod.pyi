"""stubs for pychain - Chainable expressions for functional-style data processing."""

from collections.abc import Callable, Iterable
from random import Random
from typing import Any, Self

from ._protocols import CheckFunc, ProcessFunc, TransformFunc

expr: ExprConstructor
"""
Constructs chainable expressions for functional-style data processing.
"""
iter: IterConstructor
"""Constructs chainable iterators-focused functions for functional-style data processing.
"""
struct: StructConstructor
"""Constructs chainable dict-focused functions for functional-style data processing."""

class StructConstructor:
    def __call__[K, V](self, ktype: type[K], vtype: type[V]) -> Struct[K, V, K, V]: ...

class IterConstructor:
    def __call__[T](self, dtype: type[T]) -> Iter[T, T]: ...

class ExprConstructor:
    def __call__[T](self, dtype: type[T]) -> Expr[T, T]: ...

class BaseExpr[P, R]:
    def collect(self) -> Callable[[P], R]: ...
    def into_partial[T](
        self, f: Callable[[P], T], *args: Any, **kwargs: Any
    ) -> "Expr[P, T]": ...
    def compose(self, *fns: TransformFunc[R, R]) -> Self: ...
    def clone(self) -> Self: ...

class Expr[P, R](BaseExpr[P, R]):
    def into[T](self, obj: Callable[[R], T]) -> "Expr[P, T]": ...
    def into_iter[T](self, f: Callable[[R], Iterable[T]]) -> Iter[P, T]: ...
    def into_iter_func[T](self, f: Callable[[R], T]) -> Iter[P, T]: ...
    def into_iter_range(self, start: int, stop: int, step: int = 1) -> Iter[P, int]: ...

class Iter[VP, VR](BaseExpr[Iterable[VP], VR]):
    def agg[T](self, f: Callable[[Iterable[VP]], T]) -> Expr[Iterable[VP], T]: ...
    def into[T: Iterable[Any]](
        self, obj: Callable[[Iterable[VR]], T]
    ) -> "Iter[VP, T]": ...
    def group_by[K](self, on: TransformFunc[VR, K]) -> dict[K, list[VR]]: ...
    def into_frequencies(self) -> dict[VR, int]: ...
    def reduce_by[K](
        self, key: TransformFunc[VR, K], binop: Callable[[VR, VR], VR]
    ) -> "Iter[VP, K]": ...
    def map_compose(self, fns: Iterable[ProcessFunc[VR]]) -> Self: ...
    def map[T](self, f: TransformFunc[VR, T]) -> "Iter[VP, T]": ...
    def flat_map(self, f: TransformFunc[VR, Iterable[VR]]) -> Self: ...
    def starmap(self, f: TransformFunc[VR, VR]) -> Self: ...
    def compose(self, *fns: TransformFunc[VR, VR]) -> Self: ...
    def take_while(self, predicate: CheckFunc[VR]) -> Self: ...
    def drop_while(self, predicate: CheckFunc[VR]) -> Self: ...
    def interleave(self, *others: Iterable[VR]) -> Self: ...
    def interpose(self, element: VR) -> Self: ...
    def top_n(self, n: int, key: Callable[[VR], Any] | None = None) -> Self: ...
    def random_sample(
        self, probability: float, state: Random | int | None = None
    ) -> Self: ...
    def concat(self, *others: Iterable[VR]) -> Self: ...
    def filter(self, f: CheckFunc[VR]) -> Self: ...
    def accumulate(self, f: Callable[[VR, VR], VR]) -> Self: ...
    def insert_left(self, value: VR) -> Self: ...
    def peek(self, note: str | None = None) -> Self: ...
    def peekn(self, n: int, note: str | None = None) -> Self: ...
    def head(self, n: int) -> Self: ...
    def tail(self, n: int) -> Self: ...
    def drop_first(self, n: int) -> Self: ...
    def every(self, index: int) -> Self: ...
    def repeat(self, n: int) -> Self: ...
    def unique(self) -> Self: ...
    def merge_sorted(
        self, others: Iterable[Iterable[VR]], sort_on: Callable[[VR], Any] | None = None
    ) -> Self: ...
    def tap(self, func: Callable[[VR], None]) -> Self: ...
    def zip_with(
        self, others: Iterable[Iterable[VR]], strict: bool = False
    ) -> "Iter[VP, tuple[VR, ...]]": ...
    def enumerate(self) -> "Iter[VP, tuple[int, VR]]": ...
    def flatten(self) -> "Iter[VP, Any]": ...
    def diff(
        self,
        others: Iterable[Iterable[VR]],
        default: Any | None = None,
        key: ProcessFunc[VR] | None = None,
    ) -> "Iter[VP, tuple[VR, ...]]": ...
    def partition(self, n: int, pad: VR | None = None) -> "Iter[VP, tuple[VR, ...]]": ...
    def partition_all(self, n: int) -> "Iter[VP, tuple[VR, ...]]": ...
    def rolling(self, length: int) -> "Iter[VP, tuple[VR, ...]]": ...
    def cross_join(self, other: Iterable[VR]) -> "Iter[VP, tuple[VR, VR]]": ...
    def first(self) -> Expr[Iterable[VP], VR]: ...
    def second(self) -> Expr[Iterable[VP], VR]: ...
    def last(self) -> Expr[Iterable[VP], VR]: ...
    def length(self) -> Expr[Iterable[VP], int]: ...

class Struct[KP, VP, KR, VR](BaseExpr[dict[KP, VP], dict[KR, VR]]):
    def collect(self) -> Callable[[dict[KP, VP]], dict[KR, VR]]: ...
    def map_keys[T](self, f: TransformFunc[KR, T]) -> "Struct[T, VP, KR, VR]": ...
    def map_values[T](self, f: TransformFunc[VR, T]) -> "Struct[KP, T, KR, VR]": ...
    def select(self, predicate: CheckFunc[KR]) -> Self: ...
    def filter(self, predicate: CheckFunc[VR]) -> Self: ...
    def filter_on_key(self, key: KR, predicate: CheckFunc[VR]) -> Self: ...
    def with_key(self, key: KR, value: VR) -> Self: ...
    def with_nested_key(self, keys: Iterable[KR] | KR, value: VR) -> Self: ...
    def update_in(self, *keys: KR, f: ProcessFunc[VR]) -> Self: ...
    def merge(self, *others: dict[KR, VR]) -> Self: ...
    def merge_with(
        self, f: Callable[[Iterable[VR]], VR], *others: dict[KR, VR]
    ) -> Self: ...
    def drop(self, *keys: KR) -> Self: ...
    def flatten_keys(self) -> "Struct[KP, VP, str, VR]": ...
