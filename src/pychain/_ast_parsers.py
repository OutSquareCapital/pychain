import ast
import inspect
import textwrap
import uuid
from collections.abc import Callable
from dataclasses import dataclass, field
from typing import Any

from ._protocols import (
    BUILTIN_NAMES,
    INLINEABLE_BUILTINS,
    Func,
    Names,
    Operation,
    is_placeholder,
)

type CallableAst = ast.Lambda | ast.FunctionDef
type Scope = dict[str, Any]


def generate_py_file(source_code: str, scope: dict[str, Any]) -> str:
    builder = ModuleBuilder()
    _gather_dependencies(scope, builder)
    final_source_code = source_code
    for alias, real_name in builder.alias_map.items():
        final_source_code = final_source_code.replace(alias, real_name)
    header = f"# Generated by pychain @ {uuid.uuid4().hex}\n"
    main_section = "# --- Main Function ---\n" + final_source_code
    return f"{header}\n{builder.import_section}\n\n{builder.dependencies_section}\n\n{main_section}\n"


@dataclass(slots=True)
class ModuleBuilder:
    imports: set[str] = field(default_factory=set[str])
    definitions: dict[int, str] = field(default_factory=dict[int, str])
    processed_ids: set[int] = field(default_factory=set[int])
    alias_map: dict[str, str] = field(default_factory=dict[str, str])

    def add_import(self, name: str) -> None:
        self.imports.add(f"import {name}")

    def match_node(self, node: CallableAst, name: str, obj_id: int) -> None:
        match node:
            case ast.Lambda():
                func_def = ast.FunctionDef(
                    name=name,
                    args=node.args,
                    body=[ast.Return(value=node.body)],
                    decorator_list=[],
                )
                ast.fix_missing_locations(func_def)
                self.definitions[obj_id] = ast.unparse(func_def)

            case ast.FunctionDef():
                node.name = name
                module_node = ast.Module(body=[node], type_ignores=[])
                self.definitions[obj_id] = ast.unparse(module_node)

    @property
    def import_section(self) -> str:
        return "# --- Imports ---\n" + "\n".join(sorted(list(self.imports)))

    @property
    def dependencies_section(self) -> str:
        return "# --- Dependencies ---\n" + "\n\n".join(self.definitions.values())


@dataclass(slots=True, frozen=True)
class NodeReplacer(ast.NodeTransformer):
    arg_name: str
    replacement_node: ast.AST

    def visit_Name(self, node: ast.Name) -> Any:
        return self.replacement_node if node.id == self.arg_name else node


@dataclass(slots=True)
class LambdaFinder(ast.NodeVisitor):
    found_lambda: ast.Lambda | None = None

    def visit_Lambda(self, node: ast.Lambda) -> None:
        if self.found_lambda is None:
            self.found_lambda = node


@dataclass(slots=True)
class FunctionDefFinder(ast.NodeVisitor):
    found_func: ast.FunctionDef | None = None

    def visit_FunctionDef(self, node: ast.FunctionDef) -> None:
        if self.found_func is None:
            self.found_func = node


def _extract_return_expression(func_ast: ast.FunctionDef) -> ast.expr | None:
    if len(func_ast.body) == 1 and isinstance(stmt := func_ast.body[0], ast.Return):
        return stmt.value
    return None


def get_callable_ast(func: Callable[..., Any]) -> CallableAst | None:
    try:
        raw_source = textwrap.dedent(inspect.getsource(func)).strip()
        source_to_parse = (
            f"{Names.DUMMY.value}{raw_source}"
            if raw_source.startswith((".", "["))
            else raw_source
        )
        tree = ast.parse(source_to_parse)

        lambda_finder = LambdaFinder()
        lambda_finder.visit(tree)
        if lambda_node := lambda_finder.found_lambda:
            return lambda_node

        func_def_finder = FunctionDefFinder()
        func_def_finder.visit(tree)
        return func_def_finder.found_func

    except (TypeError, OSError, SyntaxError):
        return None


@dataclass(slots=True, frozen=True)
class ScopeManager:
    scope: Scope = field(default_factory=dict[str, Any])

    def __getitem__(self, key: str) -> Any:
        return self.scope[key]

    def clear(self) -> None:
        self.scope.clear()

    def populate_from_callable(self, func: Callable[..., Any]) -> None:
        if func.__closure__:
            for var_name, cell in zip(func.__code__.co_freevars, func.__closure__):
                self.scope[var_name] = cell.cell_contents
        for name in func.__code__.co_names:
            if name in func.__globals__ and name not in BUILTIN_NAMES:
                self.scope[name] = func.__globals__[name]

    def value_to_ast(self, value: Any) -> ast.expr:
        match value:
            case bool() | int() | float() | str() | None:
                return ast.Constant(value)
            case _ if value in INLINEABLE_BUILTINS:
                return ast.Name(id=value.__name__, ctx=ast.Load())
            case _:
                base_name = getattr(value, "__name__", Names.FUNC.value)
                if not base_name.isidentifier() or base_name == "<lambda>":
                    base_name = Names.FUNC.value
                var_name = f"{Names.REF_.value}{base_name}_{id(value)}"
                self.scope[var_name] = value
                return ast.Name(id=var_name, ctx=ast.Load())

    def resolve_placeholder_ast(self, value: Any, prev_ast: ast.expr) -> ast.expr:
        return prev_ast if is_placeholder(value) else self.value_to_ast(value)

    def try_inline_call(
        self, op: Operation[Any, Any], prev_ast: ast.expr
    ) -> ast.expr | None:
        is_simple_call = all(is_placeholder(arg) for arg in op.args) and not op.kwargs
        if not is_simple_call:
            return None

        if not (node := get_callable_ast(op.func)):
            return None

        match node:
            case ast.Lambda(args=lambda_args):
                if len(lambda_args.args) == 1:
                    self.populate_from_callable(op.func)
                    arg_name = lambda_args.args[0].arg
                    return NodeReplacer(arg_name, prev_ast).visit(node.body)

            case ast.FunctionDef(args=func_args) as func_ast:
                if len(func_args.args) == 1:
                    self.populate_from_callable(op.func)
                    if return_expr := _extract_return_expression(func_ast):
                        arg_name = func_args.args[0].arg
                        return NodeReplacer(arg_name, prev_ast).visit(return_expr)

        return None

    def build_operation_ast(
        self, op: Operation[Any, Any], prev_ast: ast.expr
    ) -> ast.expr:
        if inlined_ast := self.try_inline_call(op, prev_ast):
            return inlined_ast
        func_node = self.value_to_ast(op.func)
        args_nodes = [self.resolve_placeholder_ast(arg, prev_ast) for arg in op.args]
        kwargs_nodes = [
            ast.keyword(arg=k, value=self.resolve_placeholder_ast(v, prev_ast))
            for k, v in op.kwargs.items()
        ]
        return ast.Call(func=func_node, args=args_nodes, keywords=kwargs_nodes)


def _gather_dependencies(scope: Scope, builder: ModuleBuilder) -> None:
    for name, obj in scope.items():
        obj_id = id(obj)
        if obj_id in builder.processed_ids or name.startswith(Names.PC_FUNC_.value):
            continue

        builder.processed_ids.add(obj_id)

        if isinstance(obj, Func):
            tree = ast.parse(obj.source_code)
            finder = FunctionDefFinder()
            finder.visit(tree)
            if func_def := finder.found_func:
                builder.alias_map[name] = func_def.name
                builder.definitions[obj_id] = obj.source_code
                _gather_dependencies(obj.scope, builder)
            continue

        if inspect.ismodule(obj):
            builder.add_import(obj.__name__)
            continue

        if not (inspect.isfunction(obj) or inspect.isclass(obj)):
            continue

        module = inspect.getmodule(obj)
        if module and module.__name__ == "__main__":
            if not (node := get_callable_ast(obj)):
                continue
            builder.match_node(node, name, obj_id)
        elif module:
            builder.add_import(module.__name__)
