from __future__ import annotations

import itertools
from collections.abc import Callable, Iterable
from functools import partial
from typing import TYPE_CHECKING, Any, overload

import more_itertools as mit

from .._core import IterWrapper

if TYPE_CHECKING:
    from .._expressions import Expr
    from .._iter import Iter


class BaseMap[T](IterWrapper[T]):
    @overload
    def map(self: Expr, func: Callable[[Any], Any]) -> Expr: ...
    @overload
    def map[R](self: Iter[T], func: Callable[[T], R]) -> Iter[R]: ...
    def map[R](self, func: Callable[[T], R]):
        """
        Map each element through func and return a Iter of results.

        >>> from pychain import Iter
        >>> Iter([1, 2]).map(lambda x: x + 1).into(list)
        [2, 3]
        """
        return self.apply(partial(map, func))

    @overload
    def map_star(self: Expr, func: Callable[..., Any]) -> Expr: ...
    @overload
    def map_star[U: Iterable[Any], R](
        self: Iter[U], func: Callable[..., R]
    ) -> Iter[R]: ...

    def map_star[U: Iterable[Any], R](self: IterWrapper[U], func: Callable[..., R]):
        """
        Applies a function to each element, where each element is an iterable.

        Unlike `.map()`, which passes each element as a single argument, `.starmap()` unpacks each element into positional arguments for the function.

        In short, for each `element` in the sequence, it computes `func(*element)`.

        **Tip**: It is the perfect tool to process pairs generated by `.product()` or `.zip_with()`.

        >>> from pychain import Iter
        >>> def make_sku(color, size):
        ...     return f"{color}-{size}"
        >>> data = Iter(["blue", "red"]).product(["S", "M"]).apply(list)
        >>> data.map_star(make_sku).into(list)
        ['blue-S', 'blue-M', 'red-S', 'red-M']

        This is equivalent to:
        >>> data.map(lambda x: make_sku(*x)).into(list)
        ['blue-S', 'blue-M', 'red-S', 'red-M']

        - Use map_star when the performance matters (it is faster).
        - Use map with unpacking when readability matters (the types can be inferred).
        """
        return self.apply(partial(itertools.starmap, func))

    @overload
    def map_if[R](
        self: Expr,
        predicate: Callable[[Any], bool],
        func: Callable[[Any], R],
        func_else: Callable[[Any], R] | None = None,
    ) -> Expr: ...
    @overload
    def map_if[R](
        self: Iter[T],
        predicate: Callable[[T], bool],
        func: Callable[[T], R],
        func_else: Callable[[T], R] | None = None,
    ) -> Iter[R]: ...
    def map_if[R](
        self,
        predicate: Callable[[T], bool],
        func: Callable[[T], R],
        func_else: Callable[[T], R] | None = None,
    ):
        """
        Evaluate each item from iterable using pred. If the result is equivalent to True, transform the item with func and yield it.

        Otherwise, transform the item with func_else and yield it.
        Predicate, func, and func_else should each be functions that accept one argument.

        By default, func_else is the identity function.

        >>> from pychain import Iter
        >>> from math import sqrt
        >>> iterable = Iter.from_range(-5, 5)
        >>> iterable.into(list)
        [-5, -4, -3, -2, -1, 0, 1, 2, 3, 4]
        >>> iterable.map_if(lambda x: x > 3, lambda x: "toobig").into(list)
        [-5, -4, -3, -2, -1, 0, 1, 2, 3, 'toobig']
        >>> iterable.map_if(
        ...     lambda x: x >= 0,
        ...     lambda x: f"{sqrt(x):.2f}",
        ...     lambda x: None,
        ... ).into(list)
        [None, None, None, None, None, '0.00', '1.00', '1.41', '1.73', '2.00']
        """
        return self.apply(mit.map_if, predicate, func, func_else=func_else)

    @overload
    def map_except(
        self: Expr, func: Callable[[Any], Any], *exceptions: type[BaseException]
    ) -> Expr: ...
    @overload
    def map_except[R](
        self: Iter[T], func: Callable[[T], R], *exceptions: type[BaseException]
    ) -> Iter[R]: ...
    def map_except[R](self, func: Callable[[T], R], *exceptions: type[BaseException]):
        """
        Transform each item from iterable with function and yield the result, unless function raises one of the specified exceptions.
        function is called to transform each item in iterable.

        It should accept one argument.

        If an exception other than one given by exceptions is raised by function, it is raised like normal.

        >>> from pychain import Iter
        >>> iterable = ["1", "2", "three", "4", None]
        >>> Iter(iterable).map_except(int, ValueError, TypeError).into(list)
        [1, 2, 4]
        """
        return self.apply(lambda data: mit.map_except(func, data, *exceptions))
