from __future__ import annotations

import itertools
from collections import Counter
from collections.abc import Callable, Iterable
from typing import TYPE_CHECKING, Any, Concatenate, Literal, overload

import cytoolz as cz
import more_itertools as mit

from .._core import dict_factory
from .._protocols import Pluckable, SupportsRichComparison
from ._aggregations import IterAgg
from ._process import IterProcess
from ._strings import StringNameSpace

if TYPE_CHECKING:
    from .._dict import Dict


class Iter[T](IterAgg[T], IterProcess[T]):
    """
    A wrapper around Python's built-in iterable types, providing a rich set of functional programming tools.

    It supports lazy evaluation, allowing for efficient processing of large datasets.

    It is not a collection itself, but a wrapper that provides additional methods for working with iterables.

    It can be constructed from any iterable, including `lists`, `tuples`, `sets`, and `generators`.
    """

    _data: Iterable[T]
    __slots__ = ("_data",)

    def pipe_into[**P, U](
        self,
        func: Callable[Concatenate[Iterable[T], P], Iterable[U]],
        *args: P.args,
        **kwargs: P.kwargs,
    ) -> Iter[U]:
        return Iter(func(self._data, *args, **kwargs))

    @property
    def string(self: Iter[str]) -> StringNameSpace:
        """
        A namespace for string-specific methods.
        """
        return StringNameSpace(self._data)

    # MAPS------------------------------------------------------------------
    def map[**P, R](
        self, func: Callable[Concatenate[T, P], R], *args: P.args, **kwargs: P.kwargs
    ) -> Iter[R]:
        """
        Map each element through func and return a Iter of results.

            >>> Iter([1, 2]).map(lambda x: x + 1).to_list()
            [2, 3]
        """
        return Iter(map(func, self._data, *args, **kwargs))

    def map_star[U: Iterable[Any], R](self: Iter[U], func: Callable[..., R]) -> Iter[R]:
        """
        Applies a function to each element, where each element is an iterable.

        Unlike `.map()`, which passes each element as a single argument, `.starmap()` unpacks each element into positional arguments for the function.

        In short, for each `element` in the sequence, it computes `func(*element)`.

        **Tip**: It is the perfect tool to process pairs generated by `.product()` or `.zip_with()`.

            >>> def make_sku(color, size):
            ...     return f"{color}-{size}"
            >>> Iter(["blue", "red"]).product(["S", "M"]).map_star(make_sku).to_list()
            ['blue-S', 'blue-M', 'red-S', 'red-M']
        """
        return Iter(itertools.starmap(func, self._data))

    def map_flat[R, **P](
        self,
        func: Callable[Concatenate[T, P], Iterable[R]],
        *args: P.args,
        **kwargs: P.kwargs,
    ) -> Iter[R]:
        """
        Maps a function over a sequence and flattens the result by one level.
        It applies a function to each element, where the function must return
        an iterable. The resulting iterables are then chained together into a
        single, "flat" sequence.
        It's an efficient shortcut for `.map(func).flatten()`.

            >>> # For each author, get a list of their books.
            >>> authors = Iter(["author_A", "author_B"])
            >>> def get_books(author_id):
            ...     # This could be an API call that returns a list of books
            ...     return [f"{author_id}_book1", f"{author_id}_book2"]
            >>>
            >>> authors.map_flat(get_books).to_list()
            ['author_A_book1', 'author_A_book2', 'author_B_book1', 'author_B_book2']
        """
        return Iter(
            itertools.chain.from_iterable(map(func, self._data, *args, **kwargs))
        )

    def map_join[R](
        self,
        func: Callable[[Iterable[T]], Iterable[R]],
        *others: Iterable[T],
    ) -> Iter[R]:
        """
        Equivalent to flat_map, but allow to join other iterables.

        However, it don't take additional arguments for the function.

            >>> Iter(["a", "b"]).map_join(
            ...     lambda s: [c.upper() for c in s], ["c", "d", "e"]
            ... ).to_list()
            ['A', 'B', 'C', 'D', 'E']
        """
        return Iter(itertools.chain.from_iterable(map(func, (self._data, *others))))

    def map_if[R](
        self,
        predicate: Callable[[T], bool],
        func: Callable[[T], R],
        func_else: Callable[[T], R] | None = None,
    ) -> Iter[R]:
        """
        Evaluate each item from iterable using pred. If the result is equivalent to True, transform the item with func and yield it.

        Otherwise, transform the item with func_else and yield it.
        Predicate, func, and func_else should each be functions that accept one argument.

        By default, func_else is the identity function.

            >>> from math import sqrt
            >>> iterable = list(range(-5, 5))
            >>> iterable
            [-5, -4, -3, -2, -1, 0, 1, 2, 3, 4]
            >>> Iter(iterable).map_if(lambda x: x > 3, lambda x: "toobig").to_list()
            [-5, -4, -3, -2, -1, 0, 1, 2, 3, 'toobig']
            >>> Iter(iterable).map_if(
            ...     lambda x: x >= 0,
            ...     lambda x: f"{sqrt(x):.2f}",
            ...     lambda x: None,
            ... ).to_list()
            [None, None, None, None, None, '0.00', '1.00', '1.41', '1.73', '2.00']
        """
        return Iter(mit.map_if(self._data, predicate, func, func_else=func_else))

    def map_filter[R](self, func: Callable[[T], R]) -> Iter[R]:
        """
        Apply func to every element of iterable, yielding only those which are not None.

            >>> elems = ["1", "a", "2", "b", "3"]
            >>> Iter(elems).map_filter(
            ...     lambda s: int(s) if s.isnumeric() else None
            ... ).to_list()
            [1, 2, 3]
        """
        return Iter(mit.filter_map(func, self._data))

    def map_except[R](
        self, func: Callable[[T], R], *exceptions: type[BaseException]
    ) -> Iter[R]:
        """
        Transform each item from iterable with function and yield the result, unless function raises one of the specified exceptions.
        function is called to transform each item in iterable.

        It should accept one argument.

        If an exception other than one given by exceptions is raised by function, it is raised like normal.

            >>> iterable = ["1", "2", "three", "4", None]
            >>> Iter(iterable).map_except(int, ValueError, TypeError).to_list()
            [1, 2, 4]
        """
        return Iter(mit.map_except(func, self._data, *exceptions))

    @overload
    def map_juxt[R1, R2](
        self,
        func1: Callable[[T], R1],
        func2: Callable[[T], R2],
        /,
    ) -> Iter[tuple[R1, R2]]: ...
    @overload
    def map_juxt[R, R1, R2, R3](
        self,
        func1: Callable[[T], R1],
        func2: Callable[[T], R2],
        func3: Callable[[T], R3],
        /,
    ) -> Iter[tuple[R1, R2, R3]]: ...
    @overload
    def map_juxt[R1, R2, R3, R4](
        self,
        func1: Callable[[T], R1],
        func2: Callable[[T], R2],
        func3: Callable[[T], R3],
        func4: Callable[[T], R4],
        /,
    ) -> Iter[tuple[R1, R2, R3, R4]]: ...

    def map_juxt(self, *funcs: Callable[[T], object]) -> Iter[tuple[object, ...]]:
        """
        Apply several functions to each item.
        Returns a new Iter where each item is a tuple of the results of applying each function to the original item.

            >>> Iter([1, -2, 3]).map_juxt(
            ...     lambda n: n % 2 == 0, lambda n: n > 0
            ... ).to_list()
            [(False, True), (True, False), (False, True)]
        """
        return self.map(cz.functoolz.juxt(*funcs))

    # TRANSFORMATIONS------------------------------------------------------------------
    @overload
    def zip[T1](
        self, iter1: Iterable[T1], /, *, strict: bool = ...
    ) -> Iter[tuple[T, T1]]: ...
    @overload
    def zip[T1, T2](
        self, iter1: Iterable[T1], iter2: Iterable[T2], /, *, strict: bool = ...
    ) -> Iter[tuple[T, T1, T2]]: ...
    @overload
    def zip[T1, T2, T3](
        self,
        iter1: Iterable[T1],
        iter2: Iterable[T2],
        iter3: Iterable[T3],
        /,
        *,
        strict: bool = ...,
    ) -> Iter[tuple[T, T1, T2, T3]]: ...
    @overload
    def zip[T1, T2, T3, T4](
        self,
        iter1: Iterable[T1],
        iter2: Iterable[T2],
        iter3: Iterable[T3],
        iter4: Iterable[T4],
        /,
        *,
        strict: bool = ...,
    ) -> Iter[tuple[T, T1, T2, T3, T4]]: ...
    @overload
    def zip[T1, T2, T3, T4, T5](
        self,
        iter1: Iterable[T1],
        iter2: Iterable[T2],
        iter3: Iterable[T3],
        iter4: Iterable[T4],
        iter5: Iterable[T5],
        /,
        *,
        strict: bool = ...,
    ) -> Iter[tuple[T, T1, T2, T3, T4, T5]]: ...
    def zip(
        self, *others: Iterable[Any], strict: bool = False
    ) -> Iter[tuple[Any, ...]]:
        """
        Zip with other iterables, optionally strict, wrapped in Iter.

            >>> Iter([1, 2]).zip([10, 20]).to_list()
            [(1, 10), (2, 20)]
        """
        return Iter(zip(self._data, *others, strict=strict))

    def zip_offset[U](
        self,
        *others: Iterable[T],
        offsets: list[int],
        longest: bool = False,
        fillvalue: U = None,
    ) -> Iter[tuple[T | U, ...]]:
        """
        Zip the input iterables together, but offset the i-th iterable by the i-th item in offsets.

            >>> Iter("0123").zip_offset("abcdef", offsets=(0, 1)).to_list()
            [('0', 'b'), ('1', 'c'), ('2', 'd'), ('3', 'e')]

        This can be used as a lightweight alternative to SciPy or pandas to analyze data sets in which some series have a lead or lag relationship.
        By default, the sequence will end when the shortest iterable is exhausted. To continue until the longest iterable is exhausted, set longest to True.
            >>> Iter("0123").zip_offset(
            ...     "abcdef", offsets=(0, 1), longest=True
            ... ).to_list()
            [('0', 'b'), ('1', 'c'), ('2', 'd'), ('3', 'e'), (None, 'f')]
        """
        return Iter(
            mit.zip_offset(
                self._data,
                *others,
                offsets=offsets,
                longest=longest,
                fillvalue=fillvalue,
            )
        )

    def zip_broadcast(
        self,
        *others: Iterable[T],
        scalar_types: tuple[type, type] | None = (str, bytes),
        strict: bool = False,
    ) -> Iter[tuple[T, ...]]:
        """
        Version of zip that "broadcasts" any scalar (i.e., non-iterable) items into output tuples.

            >>> iterable_1 = [1, 2, 3]
            >>> iterable_2 = ["a", "b", "c"]
            >>> scalar = "_"
            >>> Iter(iterable_1).zip_broadcast(iterable_2, scalar).to_list()
            [(1, 'a', '_'), (2, 'b', '_'), (3, 'c', '_')]

        The scalar_types keyword argument determines what types are considered scalar.
        It is set to (str, bytes) by default. Set it to None to treat strings and byte strings as iterable:

            >>> Iter("abc").zip_broadcast(0, "xyz", scalar_types=None).to_list()
            [('a', 0, 'x'), ('b', 0, 'y'), ('c', 0, 'z')]

        If the strict keyword argument is True, then UnequalIterablesError will be raised if any of the iterables have different lengths.
        """
        return Iter(
            mit.zip_broadcast(
                self._data, *others, scalar_types=scalar_types, strict=strict
            )
        )

    @overload
    def zip_equal(self) -> Iter[tuple[T]]: ...
    @overload
    def zip_equal[T2](self, __iter2: Iterable[T2]) -> Iter[tuple[T, T2]]: ...
    @overload
    def zip_equal[T2, T3](
        self, __iter2: Iterable[T2], __iter3: Iterable[T3]
    ) -> Iter[tuple[T, T2, T3]]: ...
    @overload
    def zip_equal[T2, T3, T4](
        self,
        __iter2: Iterable[T2],
        __iter3: Iterable[T3],
        __iter4: Iterable[T4],
    ) -> Iter[tuple[T, T2, T3, T4]]: ...
    @overload
    def zip_equal[T2, T3, T4, T5](
        self,
        __iter2: Iterable[T2],
        __iter3: Iterable[T3],
        __iter4: Iterable[T4],
        __iter5: Iterable[T5],
    ) -> Iter[tuple[T, T2, T3, T4, T5]]: ...
    @overload
    def zip_equal(
        __iter1: Iterable[Any],
        __iter2: Iterable[Any],
        __iter3: Iterable[Any],
        __iter4: Iterable[Any],
        __iter5: Iterable[Any],
        __iter6: Iterable[Any],
        *iterables: Iterable[Any],
    ) -> "Iter[tuple[Any, ...]]": ...
    def zip_equal(self, *others: Iterable[Any]):
        return Iter(mit.zip_equal(self._data, *others))

    def enumerate(self) -> Iter[tuple[int, T]]:
        """
        Return a Iter of (index, value) pairs.

            >>> Iter(["a", "b"]).enumerate().to_list()
            [(0, 'a'), (1, 'b')]
        """
        return Iter(enumerate(self._data))

    @overload
    def combinations(self, r: Literal[2]) -> Iter[tuple[T, T]]: ...
    @overload
    def combinations(self, r: Literal[3]) -> Iter[tuple[T, T, T]]: ...
    @overload
    def combinations(self, r: Literal[4]) -> Iter[tuple[T, T, T, T]]: ...
    @overload
    def combinations(self, r: Literal[5]) -> Iter[tuple[T, T, T, T, T]]: ...
    def combinations(self, r: int) -> Iter[tuple[T, ...]]:
        """
        Return all combinations of length r.

            >>> Iter([1, 2, 3]).combinations(2).to_list()
            [(1, 2), (1, 3), (2, 3)]
        """
        return Iter(itertools.combinations(self._data, r))

    def batch(self, n: int) -> Iter[tuple[T, ...]]:
        """
        Batch elements into tuples of length n and return a new Iter.

            >>> Iter("ABCDEFG").batch(3).to_list()
            [('A', 'B', 'C'), ('D', 'E', 'F'), ('G',)]
        """
        return Iter(itertools.batched(self._data, n))

    def zip_longest[U](
        self, *others: Iterable[T], fill_value: U = None
    ) -> Iter[tuple[U | T, ...]]:
        """
        Zip with other iterables, filling missing values.

            >>> Iter([1, 2]).zip_longest([10], fill_value=0).to_list()
            [(1, 10), (2, 0)]
        """
        return Iter(itertools.zip_longest(self._data, *others, fillvalue=fill_value))

    def permutations(self, r: int | None = None) -> Iter[tuple[T, ...]]:
        """
        Return all permutations of length r.

            >>> Iter([1, 2, 3]).permutations(2).to_list()
            [(1, 2), (1, 3), (2, 1), (2, 3), (3, 1), (3, 2)]
        """
        return Iter(itertools.permutations(self._data, r))

    def product[U](self, other: Iterable[U]) -> Iter[tuple[T, U]]:
        """
        Computes the Cartesian product with another iterable.
        This is the declarative equivalent of nested for-loops.

        It pairs every element from the source iterable with every element from the
        other iterable.

        **Tip**: This method is often chained with `.starmap()` to apply a
        function to each generated pair.

            >>> colors = Iter(["blue", "red"])
            >>> sizes = ["S", "M"]
            >>> colors.product(sizes).to_list()
            [('blue', 'S'), ('blue', 'M'), ('red', 'S'), ('red', 'M')]
        """
        return Iter(itertools.product(self._data, other))

    def combinations_with_replacement(self, r: int) -> Iter[tuple[T, ...]]:
        """
        Return all combinations with replacement of length r.

            >>> Iter([1, 2, 3]).combinations_with_replacement(2).to_list()
            [(1, 1), (1, 2), (1, 3), (2, 2), (2, 3), (3, 3)]
        """
        return Iter(itertools.combinations_with_replacement(self._data, r))

    def pairwise(self) -> Iter[tuple[T, T]]:
        """
        Return an iterator over pairs of consecutive elements.

            >>> Iter([1, 2, 3]).pairwise().to_list()
            [(1, 2), (2, 3)]
        """
        return Iter(itertools.pairwise(self._data))

    def join[R, K](
        self,
        other: Iterable[R],
        left_on: Callable[[T], K],
        right_on: Callable[[R], K],
        left_default: T | None = None,
        right_default: R | None = None,
    ) -> Iter[tuple[T, R]]:
        """
        Perform a relational join with another iterable.

            >>> colors = Iter(["blue", "red"])
            >>> sizes = ["S", "M"]
            >>> colors.join(sizes, left_on=lambda c: c, right_on=lambda s: s).to_list()
            [(None, 'S'), (None, 'M'), ('blue', None), ('red', None)]
        """
        return Iter(
            cz.itertoolz.join(
                leftkey=left_on,
                leftseq=self._data,
                rightkey=right_on,
                rightseq=other,
                left_default=left_default,
                right_default=right_default,
            )
        )

    def pluck[K, V](self: Iter[Pluckable[K, V]], key: K) -> Iter[V]:
        """
        Extract a value from each element in the sequence using a key or index.
        This is a shortcut for `.map(lambda x: x[key])`.

        >>> data = Iter([{"id": 1, "val": "a"}, {"id": 2, "val": "b"}])
        >>> data.pluck("val").to_list()
        ['a', 'b']
        >>> Iter([[10, 20], [30, 40]]).pluck(0).to_list()
        [10, 30]
        """
        return Iter(cz.itertoolz.pluck(key, self._data))

    def partition(self, n: int, pad: T | None = None) -> Iter[tuple[T, ...]]:
        """
        Partition into tuples of length n, optionally padded.

        >>> Iter([1, 2, 3, 4]).partition(2).to_list()
        [(1, 2), (3, 4)]
        """
        return Iter(cz.itertoolz.partition(n, self._data, pad))

    def partition_all(self, n: int) -> Iter[tuple[T, ...]]:
        """
        Partition into tuples of length at most n.

        >>> Iter([1, 2, 3]).partition_all(2).to_list()
        [(1, 2), (3,)]
        """
        return Iter(cz.itertoolz.partition_all(n, self._data))

    @overload
    def rolling(self, length: Literal[1]) -> Iter[tuple[T]]: ...
    @overload
    def rolling(self, length: Literal[2]) -> Iter[tuple[T, T]]: ...
    @overload
    def rolling(self, length: Literal[3]) -> Iter[tuple[T, T, T]]: ...
    @overload
    def rolling(self, length: Literal[4]) -> Iter[tuple[T, T, T, T]]: ...
    @overload
    def rolling(self, length: Literal[5]) -> Iter[tuple[T, T, T, T, T]]: ...
    @overload
    def rolling(self, length: Literal[6]) -> Iter[tuple[T, T, T, T, T, T]]: ...
    @overload
    def rolling(self, length: Literal[7]) -> Iter[tuple[T, T, T, T, T, T, T]]: ...
    @overload
    def rolling(self, length: Literal[8]) -> Iter[tuple[T, T, T, T, T, T, T, T]]: ...
    @overload
    def rolling(self, length: Literal[9]) -> Iter[tuple[T, T, T, T, T, T, T, T, T]]: ...

    def rolling(self, length: int) -> Iter[tuple[T, ...]]:
        """
        A sequence of overlapping subsequences

        >>> Iter([1, 2, 3, 4]).rolling(2).to_list()
        [(1, 2), (2, 3), (3, 4)]

        This function creates a sliding window suitable for transformations like sliding means / smoothing

        >>> mean = lambda seq: float(sum(seq)) / len(seq)
        >>> Iter([1, 2, 3, 4]).rolling(2).map(mean).to_list()
        [1.5, 2.5, 3.5]
        """
        return Iter(cz.itertoolz.sliding_window(length, self._data))

    def diff(
        self,
        *others: Iterable[T],
        key: Callable[[T], T] | None = None,
    ) -> Iter[tuple[T, ...]]:
        """
        Yield differences between sequences.

        >>> Iter([1, 2, 3]).diff([1, 2, 10]).to_list()
        [(3, 10)]
        """
        return Iter(cz.itertoolz.diff(self._data, *others, ccpdefault=None, key=key))

    def reduce_by[K](
        self, key: Callable[[T], K], binop: Callable[[T, T], T]
    ) -> Iter[K]:
        """
        Perform a simultaneous groupby and reduction
        on the elements of the sequence.

        >>> Iter([1, 2, 3, 4]).reduce_by(
        ...     key=lambda x: x % 2, binop=lambda a, b: a + b
        ... ).to_list()
        [1, 0]
        """
        return Iter(cz.itertoolz.reduceby(key, binop, self._data))

    def adjacent(
        self, predicate: Callable[[T], bool], distance: int = 1
    ) -> Iter[tuple[bool, T]]:
        """
        Return an iterable over (bool, item) tuples.
        The output is a sequence of tuples where the item is drawn from iterable.

        The bool indicates whether that item satisfies the predicate or is adjacent to an item that does.

        For example, to find whether items are adjacent to a 3:

        >>> Iter(range(6)).adjacent(lambda x: x == 3).to_list()
        [(False, 0), (False, 1), (True, 2), (True, 3), (True, 4), (False, 5)]

        Set distance to change what counts as adjacent. For example, to find whether items are two places away from a 3:

        >>> Iter(range(6)).adjacent(lambda x: x == 3, distance=2).to_list()
        [(False, 0), (True, 1), (True, 2), (True, 3), (True, 4), (True, 5)]

        This is useful for contextualizing the results of a search function.
        For example, a code comparison tool might want to identify lines that have changed, but also surrounding lines to give the viewer of the diff context.
        The predicate function will only be called once for each item in the iterable.

        See also groupby_transform, which can be used with this function to group ranges of items with the same bool value.
        """
        return Iter(mit.adjacent(predicate, self._data, distance))

    def repeat(self, n: int) -> Iter[Iterable[T]]:
        """
        Repeat the entire iterable n times (as elements) and return Iter.

        >>> Iter([1, 2]).repeat(2).to_list()
        [[1, 2], [1, 2]]
        """
        return Iter(itertools.repeat(self._data, n))

    @overload
    def repeat_last(self, default: T) -> Iter[T]: ...
    @overload
    def repeat_last[U](self, default: U) -> Iter[T | U]: ...
    def repeat_last[U](self, default: U = None) -> Iter[T | U]:
        """
        After the iterable is exhausted, keep yielding its last element.

        >>> Iter(range(3)).repeat_last().head(5).to_list()
        [0, 1, 2, 2, 2]

        If the iterable is empty, yield default forever:

        >>> Iter(range(0)).repeat_last(42).head(5).to_list()
        [42, 42, 42, 42, 42]
        """
        return Iter(mit.repeat_last(self._data, default))

    def flatten[U](self: Iter[Iterable[U]]) -> Iter[U]:
        """
        Flatten one level of nesting and return a new Iterable wrapper.

        >>> Iter([[1, 2], [3]]).flatten().to_list()
        [1, 2, 3]
        """
        return Iter(itertools.chain.from_iterable(self._data))

    def split_after(
        self, predicate: Callable[[T], bool], max_split: int = -1
    ) -> Iter[list[T]]:
        """
        Yield lists of items from iterable, where each list ends with an item where callable pred returns True:
        At most maxsplit splits are done.
        If maxsplit is not specified or -1, then there is no limit on the number of splits:

        >>> Iter("one1two2").split_after(lambda s: s.isdigit()).to_list()
        [['o', 'n', 'e', '1'], ['t', 'w', 'o', '2']]

        >>> Iter(range(10)).split_after(lambda n: n % 3 == 0).to_list()
        [[0], [1, 2, 3], [4, 5, 6], [7, 8, 9]]

        >>> Iter(range(10)).split_after(lambda n: n % 3 == 0, max_split=2).to_list()
        [[0], [1, 2, 3], [4, 5, 6, 7, 8, 9]]
        """
        return Iter(mit.split_after(self._data, predicate, max_split))

    def chunked(self, n: int, strict: bool = False) -> Iter[list[T]]:
        """
        Break iterable into lists of length n.

        By default, the last yielded list will have fewer than *n* elements if the length of *iterable* is not divisible by *n*.

        To use a fill-in value instead, see the :func:`grouper` recipe.

        If the length of *iterable* is not divisible by *n* and *strict* is
        ``True``, then ``ValueError`` will be raised before the last
        list is yielded.

        >>> Iter([1, 2, 3, 4, 5, 6]).chunked(3).to_list()
        [[1, 2, 3], [4, 5, 6]]
        >>> Iter([1, 2, 3, 4, 5, 6, 7, 8]).chunked(3).to_list()
        [[1, 2, 3], [4, 5, 6], [7, 8]]
        """
        return Iter(mit.chunked(self._data, n, strict))

    def chunked_even(self, n: int) -> Iter[list[T]]:
        """
        Break iterable into lists of approximately length n.
        Items are distributed such the lengths of the lists differ by at most 1 item.

        >>> iterable = [1, 2, 3, 4, 5, 6, 7]
        >>> Iter(iterable).chunked_even(3).to_list()  # List lengths: 3, 2, 2
        [[1, 2, 3], [4, 5], [6, 7]]
        >>> Iter(iterable).chunked(3).to_list()  # List lengths: 3, 3, 1
        [[1, 2, 3], [4, 5, 6], [7]]
        """
        return Iter(mit.chunked_even(self._data, n))

    # PROCESSING------------------------------------------------------------------
    def sort[U: SupportsRichComparison[Any]](
        self: Iter[U],
        key: Callable[[U], Any] | None = None,
        reverse: bool = False,
    ) -> Iter[U]:
        """Sort the elements of the sequence.
        Note: This method must consume the entire iterable to perform the sort.
        The result is a new iterable over the sorted sequence.

        >>> Iter([3, 1, 2]).sort().to_list()
        [1, 2, 3]
        >>> data = Iter([{"age": 30}, {"age": 20}])
        >>> data.sort(key=lambda x: x["age"]).to_list()
        [{'age': 20}, {'age': 30}]
        """
        return self._new(sorted(self._data, key=key, reverse=reverse))

    def most_common(self, n: int | None = None) -> Iter[tuple[T, int]]:
        """
        Return an iterable over the n most common elements and their counts from the most common to the least.
        If n is None, then all elements are returned.

        >>> Iter([1, 1, 2, 3, 3, 3]).most_common(2).to_list()
        [(3, 3), (1, 2)]
        """

        return Iter(Counter(self._data).most_common(n))

    def elements(self) -> Iter[T]:
        """
        Iterator over elements repeating each as many times as its count.

        >>> Iter("ABCABC").elements().sort()
        ['A', 'A', 'B', 'B', 'C', 'C']

        Knuth's example for prime factors of 1836:  2**2 * 3**3 * 17**1

        >>> import math
        >>> Iter({2: 2, 3: 3, 17: 1}).elements().pipe_into(math.prod)
        1836

        Note, if an element's count has been set to zero or is a negative
        number, elements() will ignore it.

        """
        return Iter(Counter(self._data).elements())

    def group_by[K](self, on: Callable[[T], K]) -> Dict[K, list[T]]:
        """
        Group elements by key function and return a Dict result.

        >>> from pychain import Iter
        >>> Iter(["a", "bb"]).group_by(len)
        {1: ['a'], 2: ['bb']}
        """
        return dict_factory(cz.itertoolz.groupby(on, self._data))

    def frequencies(self) -> Dict[T, int]:
        """
        Return a Dict of value frequencies.

        >>> from pychain import Iter
        >>> Iter([1, 1, 2]).frequencies()
        {1: 2, 2: 1}
        """
        return dict_factory(cz.itertoolz.frequencies(self._data))
