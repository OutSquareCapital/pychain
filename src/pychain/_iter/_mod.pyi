from collections.abc import Callable, Iterable
from random import Random
from typing import Any, overload

from .._protocols import CheckFunc, ProcessFunc, TransformFunc

class IterConstructor:
    @overload
    def __call__(self) -> Iter[Any, Any]: ...
    @overload
    def __call__[T](self, *dtype: type[Iterable[T] | T]) -> Iter[T, T]: ...
    def attr[T](self, name: str, dtype: type[Iterable[T] | T]) -> "Iter[T, T]": ...
    def item[T](self, key: Any, dtype: type[Iterable[T] | T]) -> "Iter[T, T]": ...

class Iter[V, V1]:
    def __call__(self, value: Iterable[V]) -> Iterable[V1]: ...
    def clone(self) -> "Iter[V, V1]": ...
    def unwrap(self) -> Iterable[V]: ...
    def group_by[K](self, on: TransformFunc[V, K]) -> dict[K, list[V]]: ...
    def into_frequencies(self) -> dict[V, int]: ...
    def reduce_by[K](
        self, key: TransformFunc[V, K], binop: Callable[[V, V], V]
    ) -> "Iter[V, K]": ...
    def map[T](self, f: TransformFunc[V, T]) -> "Iter[V, T]": ...
    def flat_map(self, f: TransformFunc[V, Iterable[V1]]) -> "Iter[V, V1]": ...
    def starmap(self, f: TransformFunc[V, V1]) -> "Iter[V, V1]": ...
    def compose(self, *fns: TransformFunc[V, V1]) -> "Iter[V, V1]": ...
    def take_while(self, predicate: CheckFunc[V]) -> "Iter[V, V1]": ...
    def drop_while(self, predicate: CheckFunc[V]) -> "Iter[V, V1]": ...
    def interleave(self, *others: Iterable[V]) -> "Iter[V, V1]": ...
    def interpose(self, element: V) -> "Iter[V, V1]": ...
    def top_n(self, n: int, key: Callable[[V], Any] | None = None) -> "Iter[V, V1]": ...
    def random_sample(
        self, probability: float, state: Random | int | None = None
    ) -> "Iter[V, V1]": ...
    def concat(self, *others: Iterable[V]) -> "Iter[V, V1]": ...
    def filter(self, f: CheckFunc[V]) -> "Iter[V, V1]": ...
    def accumulate(self, f: Callable[[V, V], V]) -> "Iter[V, V1]": ...
    def insert_left(self, value: V) -> "Iter[V, V1]": ...
    def peek(self, note: str | None = None) -> "Iter[V, V1]": ...
    def peekn(self, n: int, note: str | None = None) -> "Iter[V, V1]": ...
    def head(self, n: int) -> "Iter[V, V1]": ...
    def tail(self, n: int) -> "Iter[V, V1]": ...
    def drop_first(self, n: int) -> "Iter[V, V1]": ...
    def every(self, index: int) -> "Iter[V, V1]": ...
    def repeat(self, n: int) -> "Iter[V, V1]": ...
    def unique(self) -> "Iter[V, V1]": ...
    def cumsum(self) -> "Iter[V, V1]": ...
    def cumprod(self) -> "Iter[V, V1]": ...
    def merge_sorted(
        self, *others: Iterable[V], sort_on: Callable[[V], Any] | None = None
    ) -> "Iter[V, V1]": ...
    def tap(self, func: Callable[[V], None]) -> "Iter[V, V1]": ...
    def zip_with(
        self, *others: Iterable[V], strict: bool = False
    ) -> "Iter[V, tuple[V, ...]]": ...
    def enumerate(self) -> "Iter[V, tuple[int, V]]": ...
    def flatten(self) -> "Iter[V, Any]": ...
    def diff(
        self,
        *others: Iterable[V],
        default: Any | None = None,
        key: ProcessFunc[V] | None = None,
    ) -> "Iter[V, tuple[V, ...]]": ...
    def partition(self, n: int, pad: V | None = None) -> "Iter[V, tuple[V, ...]]": ...
    def partition_all(self, n: int) -> "Iter[V, tuple[V, ...]]": ...
    def rolling(self, length: int) -> "Iter[V, tuple[V, ...]]": ...
    def cross_join(self, other: Iterable[V1]) -> "Iter[V, tuple[V1, V]]": ...
