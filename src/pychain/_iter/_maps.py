from __future__ import annotations

import itertools
from collections.abc import Callable, Iterable
from functools import partial
from typing import TYPE_CHECKING, Any

import more_itertools as mit

from .._core import IterWrapper

if TYPE_CHECKING:
    from ._main import Iter


class IterMap[T](IterWrapper[T]):
    def map[R](self, func: Callable[[T], R]) -> Iter[R]:
        """
        Map each element through func and return a Iter of results.

        >>> from pychain import Iter
        >>> Iter([1, 2]).map(lambda x: x + 1).into(list)
        [2, 3]
        """
        return self.apply(partial(map, func))

    def map_star[U: Iterable[Any], R](
        self: IterMap[U], func: Callable[[Iterable[Any]], R]
    ) -> Iter[R]:
        """
        Applies a function to each element, where each element is an iterable.

        Unlike `.map()`, which passes each element as a single argument, `.starmap()` unpacks each element into positional arguments for the function.

        In short, for each `element` in the sequence, it computes `func(*element)`.

        **Tip**: It is the perfect tool to process pairs generated by `.product()` or `.zip_with()`.

        >>> from pychain import Iter
        >>> def make_sku(color, size):
        ...     return f"{color}-{size}"
        >>> Iter(["blue", "red"]).product(["S", "M"]).map_star(make_sku).into(list)
        ['blue-S', 'blue-M', 'red-S', 'red-M']
        """
        return self.apply(partial(itertools.starmap, func))

    def map_if[R](
        self,
        predicate: Callable[[T], bool],
        func: Callable[[T], R],
        func_else: Callable[[T], R] | None = None,
    ) -> Iter[R]:
        """
        Evaluate each item from iterable using pred. If the result is equivalent to True, transform the item with func and yield it.

        Otherwise, transform the item with func_else and yield it.
        Predicate, func, and func_else should each be functions that accept one argument.

        By default, func_else is the identity function.

        >>> from pychain import Iter
        >>> from math import sqrt
        >>> iterable = Iter.from_range(-5, 5)
        >>> iterable.into(list)
        [-5, -4, -3, -2, -1, 0, 1, 2, 3, 4]
        >>> iterable.map_if(lambda x: x > 3, lambda x: "toobig").into(list)
        [-5, -4, -3, -2, -1, 0, 1, 2, 3, 'toobig']
        >>> iterable.map_if(
        ...     lambda x: x >= 0,
        ...     lambda x: f"{sqrt(x):.2f}",
        ...     lambda x: None,
        ... ).into(list)
        [None, None, None, None, None, '0.00', '1.00', '1.41', '1.73', '2.00']
        """
        return self.apply(mit.map_if, predicate, func, func_else=func_else)

    def map_except[R](
        self, func: Callable[[T], R], *exceptions: type[BaseException]
    ) -> Iter[R]:
        """
        Transform each item from iterable with function and yield the result, unless function raises one of the specified exceptions.
        function is called to transform each item in iterable.

        It should accept one argument.

        If an exception other than one given by exceptions is raised by function, it is raised like normal.

        >>> from pychain import Iter
        >>> iterable = ["1", "2", "three", "4", None]
        >>> Iter(iterable).map_except(int, ValueError, TypeError).into(list)
        [1, 2, 4]
        """
        return self.apply(lambda data: mit.map_except(func, data, *exceptions))
