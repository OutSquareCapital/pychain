from __future__ import annotations

import itertools
from collections.abc import Callable, Iterable
from typing import TYPE_CHECKING, Any, Concatenate

import more_itertools as mit

from .._core import CommonBase, iter_factory

if TYPE_CHECKING:
    from ._main import Iter


class IterMap[T](CommonBase[Iterable[T]]):
    _data: Iterable[T]

    def map[**P, R](
        self, func: Callable[Concatenate[T, P], R], *args: P.args, **kwargs: P.kwargs
    ) -> Iter[R]:
        """
        Map each element through func and return a Iter of results.

        >>> from pychain import Iter
        >>> Iter([1, 2]).map(lambda x: x + 1).to_list()
        [2, 3]
        """
        return iter_factory(map(func, self._data, *args, **kwargs))

    def map_star[U: Iterable[Any], R](
        self: IterMap[U], func: Callable[..., R]
    ) -> Iter[R]:
        """
        Applies a function to each element, where each element is an iterable.

        Unlike `.map()`, which passes each element as a single argument, `.starmap()` unpacks each element into positional arguments for the function.

        In short, for each `element` in the sequence, it computes `func(*element)`.

        **Tip**: It is the perfect tool to process pairs generated by `.product()` or `.zip_with()`.

        >>> from pychain import Iter
        >>> def make_sku(color, size):
        ...     return f"{color}-{size}"
        >>> Iter(["blue", "red"]).product(["S", "M"]).map_star(make_sku).to_list()
        ['blue-S', 'blue-M', 'red-S', 'red-M']
        """
        return iter_factory(itertools.starmap(func, self._data))

    def map_flat[R, **P](
        self,
        func: Callable[Concatenate[T, P], Iterable[R]],
        *args: P.args,
        **kwargs: P.kwargs,
    ) -> Iter[R]:
        """
        Maps a function over a sequence and flattens the result by one level.
        It applies a function to each element, where the function must return
        an iterable. The resulting iterables are then chained together into a
        single, "flat" sequence.
        It's an efficient shortcut for `.map(func).flatten()`.

        >>> from pychain import Iter
        >>> # For each author, get a list of their books.
        >>> authors = Iter(["author_A", "author_B"])
        >>> def get_books(author_id):
        ...     # This could be an API call that returns a list of books
        ...     return [f"{author_id}_book1", f"{author_id}_book2"]
        >>>
        >>> authors.map_flat(get_books).to_list()
        ['author_A_book1', 'author_A_book2', 'author_B_book1', 'author_B_book2']
        """
        return iter_factory(
            itertools.chain.from_iterable(map(func, self._data, *args, **kwargs))
        )

    def map_join[R](
        self,
        func: Callable[[T], R],
        *others: Iterable[T],
    ) -> Iter[R]:
        """
        Equivalent to map, but allow to join other iterables.

        However, it don't take additional arguments for the function.

        >>> from pychain import Iter
        >>> Iter(["a", "b"]).map_join(str.upper, ["c", "d", "e"]).to_list()
        ['A', 'B', 'C', 'D', 'E']
        """
        return iter_factory(
            map(func, itertools.chain.from_iterable((self._data, *others)))
        )

    def map_if[R](
        self,
        predicate: Callable[[T], bool],
        func: Callable[[T], R],
        func_else: Callable[[T], R] | None = None,
    ) -> Iter[R]:
        """
        Evaluate each item from iterable using pred. If the result is equivalent to True, transform the item with func and yield it.

        Otherwise, transform the item with func_else and yield it.
        Predicate, func, and func_else should each be functions that accept one argument.

        By default, func_else is the identity function.

        >>> from pychain import Iter
        >>> from math import sqrt
        >>> iterable = list(range(-5, 5))
        >>> iterable
        [-5, -4, -3, -2, -1, 0, 1, 2, 3, 4]
        >>> Iter(iterable).map_if(lambda x: x > 3, lambda x: "toobig").to_list()
        [-5, -4, -3, -2, -1, 0, 1, 2, 3, 'toobig']
        >>> Iter(iterable).map_if(
        ...     lambda x: x >= 0,
        ...     lambda x: f"{sqrt(x):.2f}",
        ...     lambda x: None,
        ... ).to_list()
        [None, None, None, None, None, '0.00', '1.00', '1.41', '1.73', '2.00']
        """
        return iter_factory(
            mit.map_if(self._data, predicate, func, func_else=func_else)
        )

    def map_filter[R](self, func: Callable[[T], R]) -> Iter[R]:
        """
        Apply func to every element of iterable, yielding only those which are not None.

        >>> from pychain import Iter
        >>> elems = ["1", "a", "2", "b", "3"]
        >>> Iter(elems).map_filter(
        ...     lambda s: int(s) if s.isnumeric() else None
        ... ).to_list()
        [1, 2, 3]
        """
        return iter_factory(mit.filter_map(func, self._data))

    def map_except[R](
        self, func: Callable[[T], R], *exceptions: type[BaseException]
    ) -> Iter[R]:
        """
        Transform each item from iterable with function and yield the result, unless function raises one of the specified exceptions.
        function is called to transform each item in iterable.

        It should accept one argument.

        If an exception other than one given by exceptions is raised by function, it is raised like normal.

        >>> from pychain import Iter
        >>> iterable = ["1", "2", "three", "4", None]
        >>> Iter(iterable).map_except(int, ValueError, TypeError).to_list()
        [1, 2, 4]
        """
        return iter_factory(mit.map_except(func, self._data, *exceptions))
