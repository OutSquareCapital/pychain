from __future__ import annotations

import itertools
from collections.abc import Callable, Iterable, Iterator
from functools import partial
from typing import TYPE_CHECKING, Any, overload

import cytoolz as cz
import more_itertools as mit

from .._core import IterWrapper

if TYPE_CHECKING:
    from ._main import Iter


class BaseMap[T](IterWrapper[T]):
    def map[R](self, func: Callable[[T], R]) -> Iter[R]:
        """
        Map each element through func and return a Iter of results.

        >>> from pychain import Iter
        >>> Iter([1, 2]).map(lambda x: x + 1).into(list)
        [2, 3]
        """
        return self.apply(partial(map, func))

    def map_star[U: Iterable[Any], R](
        self: IterWrapper[U], func: Callable[..., R]
    ) -> Iter[R]:
        """
        Applies a function to each element, where each element is an iterable.

        Unlike `.map()`, which passes each element as a single argument, `.starmap()` unpacks each element into positional arguments for the function.

        In short, for each `element` in the sequence, it computes `func(*element)`.

        **Tip**: It is the perfect tool to process pairs generated by `.product()` or `.zip_with()`.

        >>> from pychain import Iter
        >>> def make_sku(color, size):
        ...     return f"{color}-{size}"
        >>> data = Iter(["blue", "red"]).product(["S", "M"]).apply(list)
        >>> data.map_star(make_sku).into(list)
        ['blue-S', 'blue-M', 'red-S', 'red-M']

        This is equivalent to:
        >>> data.map(lambda x: make_sku(*x)).into(list)
        ['blue-S', 'blue-M', 'red-S', 'red-M']

        - Use map_star when the performance matters (it is faster).
        - Use map with unpacking when readability matters (the types can be inferred).
        """

        return self.apply(partial(itertools.starmap, func))

    def map_if[R](
        self,
        predicate: Callable[[T], bool],
        func: Callable[[T], R],
        func_else: Callable[[T], R] | None = None,
    ) -> Iter[R]:
        """
        Evaluate each item from iterable using pred. If the result is equivalent to True, transform the item with func and yield it.

        Otherwise, transform the item with func_else and yield it.
        Predicate, func, and func_else should each be functions that accept one argument.

        By default, func_else is the identity function.

        >>> from pychain import Iter
        >>> from math import sqrt
        >>> iterable = Iter.from_range(-5, 5)
        >>> iterable.into(list)
        [-5, -4, -3, -2, -1, 0, 1, 2, 3, 4]
        >>> iterable.map_if(lambda x: x > 3, lambda x: "toobig").into(list)
        [-5, -4, -3, -2, -1, 0, 1, 2, 3, 'toobig']
        >>> iterable.map_if(
        ...     lambda x: x >= 0,
        ...     lambda x: f"{sqrt(x):.2f}",
        ...     lambda x: None,
        ... ).into(list)
        [None, None, None, None, None, '0.00', '1.00', '1.41', '1.73', '2.00']
        """
        return self.apply(mit.map_if, predicate, func, func_else=func_else)

    def map_except[R](
        self, func: Callable[[T], R], *exceptions: type[BaseException]
    ) -> Iter[R]:
        """
        Transform each item from iterable with function and yield the result, unless function raises one of the specified exceptions.
        function is called to transform each item in iterable.

        It should accept one argument.

        If an exception other than one given by exceptions is raised by function, it is raised like normal.

        >>> from pychain import Iter
        >>> iterable = ["1", "2", "three", "4", None]
        >>> Iter(iterable).map_except(int, ValueError, TypeError).into(list)
        [1, 2, 4]
        """
        return self.apply(lambda data: mit.map_except(func, data, *exceptions))

    def repeat(self, n: int) -> Iter[Iterable[T]]:
        """
        Repeat the entire iterable n times (as elements) and return Iter.

        >>> from pychain import Iter
        >>> Iter([1, 2]).repeat(2).into(list)
        [[1, 2], [1, 2]]
        """
        return self.apply(partial(itertools.repeat, times=n))

    @overload
    def repeat_last(self, default: T) -> Iter[T]: ...
    @overload
    def repeat_last[U](self, default: U) -> Iter[T | U]: ...
    def repeat_last[U](self, default: U = None) -> Iter[T | U]:
        """
        After the iterable is exhausted, keep yielding its last element.

        >>> from pychain import Iter
        >>> Iter.from_range(0, 3).repeat_last().head(5).into(list)
        [0, 1, 2, 2, 2]

        If the iterable is empty, yield default forever:

        >>> Iter.from_range(0, 0).repeat_last(42).head(5).into(list)
        [42, 42, 42, 42, 42]
        """
        return self.apply(mit.repeat_last, default)

    def ichunked(self, n: int) -> Iter[Iterator[T]]:
        """

        Break *iterable* into sub-iterables with *n* elements each.

        If the sub-iterables are read in order, the elements of *iterable*
        won't be stored in memory.

        If they are read out of order, :func:`itertools.tee` is used to cache
        elements as necessary.

        >>> from pychain import Iter
        >>> all_chunks = Iter.from_count().ichunked(4).unwrap()
        >>> c_1, c_2, c_3 = next(all_chunks), next(all_chunks), next(all_chunks)
        >>> list(c_2)  # c_1's elements have been cached; c_3's haven't been
        [4, 5, 6, 7]
        >>> list(c_1)
        [0, 1, 2, 3]
        >>> list(c_3)
        [8, 9, 10, 11]
        """
        return self.apply(mit.ichunked, n)

    @overload
    def explode[U](
        self: IterWrapper[Iterable[Iterable[Iterable[U]]]],
    ) -> Iter[Iterable[Iterable[U]]]: ...
    @overload
    def explode[U](self: IterWrapper[Iterable[Iterable[U]]]) -> Iter[Iterable[U]]: ...
    @overload
    def explode[U](self: IterWrapper[Iterable[U]]) -> Iter[U]: ...
    def explode(self: IterWrapper[Iterable[Any]]) -> Iter[Any]:
        """
        Flatten one level of nesting and return a new Iterable wrapper.

        This is a shortcut for `.apply(itertools.chain.from_iterable)`.

        >>> from pychain import Iter
        >>> Iter([[1, 2], [3]]).explode().into(list)
        [1, 2, 3]
        """
        return self.apply(itertools.chain.from_iterable)

    def pluck(self, key: int | str | Iterable[int] | Iterable[str]) -> Iter[T]:
        """
        Get an element or several elements from each item in a sequence.

        ``pluck`` maps itertoolz.get over a sequence and returns one or more elements of each item in the sequence.

        When given a single key, `pluck` can be thought of as .map(lambda x: x[key]).

        >>> from pychain import Iter
        >>> data = [{"id": 1, "name": "Cheese"}, {"id": 2, "name": "Pies"}]
        >>> Iter(data).pluck("name").into(list)
        ['Cheese', 'Pies']
        >>> Iter([[1, 2, 3], [4, 5, 7]]).pluck([0, 1]).into(list)
        [(1, 2), (4, 5)]
        """
        return self.apply(partial(cz.itertoolz.pluck, key))
