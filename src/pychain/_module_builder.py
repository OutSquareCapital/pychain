import ast
import hashlib
import inspect
from dataclasses import dataclass, field
from typing import Any

from ._ast_parsers import FunctionDefFinder, get_callable_ast
from ._protocols import CallableAst, Func, Names, Scope


def generate_py_file(source_code: str, scope: Scope) -> str:
    builder = ModuleBuilder()
    _gather_dependencies(scope, builder)
    final_source_code = source_code
    for alias, real_name in builder.alias_map.items():
        final_source_code = final_source_code.replace(alias, real_name)
    tree = ast.parse(final_source_code)
    if isinstance(tree.body[0], ast.FunctionDef):
        decorator = ast.Name(id="cython.ccall", ctx=ast.Load())
        tree.body[0].decorator_list.insert(0, decorator)
        final_source_code = ast.unparse(tree)
    file_content_for_hash = f"{builder.import_section}\n\n{builder.dependencies_section}\n\n{final_source_code}"
    file_hash = hashlib.sha256(file_content_for_hash.encode()).hexdigest()
    header = f"# Generated by pychain | hash: {file_hash[:16]}\n# type: ignore\n"
    main_section = "# --- Main Function ---\n" + final_source_code
    return f"{header}\n{builder.import_section}\n\n{builder.dependencies_section}\n\n{main_section}\n"


@dataclass(slots=True)
class ModuleBuilder:
    imports: set[str] = field(default_factory=set[str])
    definitions: dict[int, str] = field(default_factory=dict[int, str])
    processed_ids: set[int] = field(default_factory=set[int])
    alias_map: dict[str, str] = field(default_factory=dict[str, str])

    def add_import(self, name: str) -> None:
        self.imports.add(f"import {name}")

    def add_func_dependency(self, func_obj: Func[Any, Any], ref_name: str) -> None:
        tree = ast.parse(func_obj.source_code)
        finder = FunctionDefFinder()
        finder.visit(tree)
        if func_def := finder.found_func:
            decorator = ast.Name(id="cython.cfunc", ctx=ast.Load())
            func_def.decorator_list.insert(0, decorator)

            self.definitions[id(func_obj)] = ast.unparse(func_def)
            self.alias_map[ref_name] = func_def.name

    def match_node(self, node: CallableAst, name: str, obj_id: int) -> None:
        func_def: ast.FunctionDef | None = None
        match node:
            case ast.Lambda() as lambda_node:
                func_def = ast.FunctionDef(
                    name=name,
                    args=lambda_node.args,
                    body=[ast.Return(value=lambda_node.body)],
                    decorator_list=[],
                )
            case ast.FunctionDef() as func_def_node:
                func_def_node.name = name
                func_def = func_def_node

        if func_def:
            decorator = ast.Name(id="cython.cfunc", ctx=ast.Load())
            func_def.decorator_list.insert(0, decorator)

            ast.fix_missing_locations(func_def)
            self.definitions[obj_id] = ast.unparse(func_def)

    @property
    def import_section(self) -> str:
        all_imports = self.imports.copy()
        all_imports.add("import cython")
        return "# --- Imports ---\n" + "\n".join(sorted(list(all_imports)))

    @property
    def dependencies_section(self) -> str:
        return "# --- Dependencies ---\n" + "\n\n".join(self.definitions.values())


def _gather_dependencies(scope: Scope, builder: ModuleBuilder) -> None:
    for name, obj in scope.items():
        obj_id = id(obj)
        if obj_id in builder.processed_ids or name.startswith(Names.PC_FUNC_.value):
            continue
        builder.processed_ids.add(obj_id)

        if isinstance(obj, Func):
            builder.add_func_dependency(obj, name)  # type: ignore
            _gather_dependencies(obj.scope, builder)
            continue

        if inspect.ismodule(obj):
            builder.add_import(obj.__name__)
            continue

        if not (inspect.isfunction(obj) or inspect.isclass(obj)):
            continue

        module = inspect.getmodule(obj)
        if module and module.__name__ == "__main__":
            if node := get_callable_ast(obj):
                builder.match_node(node, name, obj_id)
        elif module:
            builder.add_import(module.__name__)
