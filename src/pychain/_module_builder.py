import ast
import hashlib
import inspect
import textwrap
from dataclasses import dataclass, field
from pathlib import Path
from typing import Any

from ._ast_parsers import (
    FunctionDefFinder,
    add_cfunc,
    get_callable_ast,
    match_node,
)
from ._protocols import CallableAst, Func, Names, Scope


@dataclass(slots=True)
class SourceCode:
    code: str
    func_name: str

    def __repr__(self) -> str:
        indented_code: str = textwrap.indent(self.code, "    ")
        return f"pychain\n-- Source --\n{indented_code}"

    def as_tree(self) -> ast.Module:
        return ast.parse(self.code)

    def clean_aliases(self, alias_map: dict[str, str]):
        for alias, real_name in alias_map.items():
            self.code = self.code.replace(alias, real_name)
        return self

    def get_hash(self) -> str:
        return hashlib.sha256(self.code.encode("utf-8")).hexdigest()

    def write_to_file(self, path: Path) -> None:
        path.write_text(self.code, encoding="utf-8")

    def add_cython_decorators(self):
        tree = self.as_tree()
        if isinstance(tree.body[0], ast.FunctionDef):
            decorator = ast.Name(id="cython.ccall", ctx=ast.Load())
            tree.body[0].decorator_list.insert(0, decorator)
            self.code = ast.unparse(tree)
        return self

    def finalize(self, import_section: str, dependencies_section: str):
        file_content = f"{import_section}\n\n{dependencies_section}\n\n{self.code}"
        self.code = f"# Generated by pychain\n# type: ignore\n{file_content}"
        return self


@dataclass(slots=True)
class ModuleBuilder:
    imports: set[str] = field(default_factory=set[str])
    definitions: dict[int, str] = field(default_factory=dict[int, str])
    processed_ids: set[int] = field(default_factory=set[int])
    alias_map: dict[str, str] = field(default_factory=dict[str, str])

    def generate(self, source: SourceCode, scope: Scope):
        self._gather_dependencies(scope)
        return (
            source.clean_aliases(self.alias_map)
            .add_cython_decorators()
            .finalize(self.import_section, self.dependencies_section)
        )

    def _add_import(self, name: str) -> None:
        self.imports.add(f"import {name}")

    def _add_func_dependency(self, func_obj: Func[Any, Any], ref_name: str) -> None:
        tree = ast.parse(func_obj.source_code)
        finder = FunctionDefFinder()
        finder.visit(tree)
        if func_def := finder.found_func:
            decorator = ast.Name(id="cython.cfunc", ctx=ast.Load())
            func_def.decorator_list.insert(0, decorator)

            self.definitions[id(func_obj)] = ast.unparse(func_def)
            self.alias_map[ref_name] = func_def.name

    def _add_func(self, node: CallableAst, name: str, obj_id: int) -> None:
        func_def: ast.FunctionDef | None = match_node(node, name)
        if func_def:
            self.definitions[obj_id] = add_cfunc(func_def)

    @property
    def import_section(self) -> str:
        all_imports = self.imports.copy()
        all_imports.add("import cython")
        return "# --- Imports ---\n" + "\n".join(sorted(list(all_imports)))

    @property
    def dependencies_section(self) -> str:
        return "# --- Dependencies ---\n" + "\n\n".join(self.definitions.values())

    def _gather_dependencies(self, scope: Scope) -> None:
        for name, obj in scope.items():
            obj_id = id(obj)
            if obj_id in self.processed_ids or name.startswith(Names.PC_FUNC_.value):
                continue
            self.processed_ids.add(obj_id)

            if isinstance(obj, Func):
                self._add_func_dependency(obj, name)  # type: ignore
                self._gather_dependencies(obj.scope)
                continue

            if inspect.ismodule(obj):
                self._add_import(obj.__name__)
                continue

            if not (inspect.isfunction(obj) or inspect.isclass(obj)):
                continue

            module = inspect.getmodule(obj)
            if module and module.__name__ == "__main__":
                if node := get_callable_ast(obj):
                    self._add_func(node, name, obj_id)
            elif module:
                self._add_import(module.__name__)
