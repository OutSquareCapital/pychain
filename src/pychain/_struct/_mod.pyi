from collections.abc import Callable, Iterable
from typing import Self, Any, overload
from .._protocols import CheckFunc, ProcessFunc, TransformFunc

class StructConstructor:
    @overload
    def __call__(self) -> Struct[Any, Any]: ...
    @overload
    def __call__[K, V](self, *ktype: type[K], vtype: type[V]) -> Struct[K, V]: ...

class Struct[K, V]:
    def map_keys[K1](self, f: TransformFunc[K, K1]) -> "Struct[K1, V]": ...
    def map_values[V1](self, f: TransformFunc[V, V1]) -> "Struct[K, V1]": ...
    def select(self, predicate: CheckFunc[K]) -> Self: ...
    def filter(self, predicate: CheckFunc[V]) -> Self: ...
    def filter_on_key(self, key: K, predicate: CheckFunc[V]) -> Self: ...
    def with_key(self, key: K, value: V) -> Self: ...
    def with_nested_key(self, keys: Iterable[K] | K, value: V) -> Self: ...
    def update_in(self, *keys: K, f: ProcessFunc[V]) -> Self: ...
    def merge(self, *others: dict[K, V]) -> Self: ...
    def merge_with(
        self, f: Callable[[Iterable[V]], V], *others: dict[K, V]
    ) -> Self: ...
    def drop(self, *keys: K) -> Self: ...
    def flatten_keys(self) -> "Struct[str, V]": ...
    def to_obj[T](self, obj: Callable[[dict[K, V]], T]) -> T: ...
