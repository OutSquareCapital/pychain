from collections.abc import Callable, Iterable
from typing import Self, Any, overload
from .._protocols import CheckFunc, ProcessFunc, TransformFunc

class StructConstructor:
    @overload
    def __call__(self) -> Struct[Any, Any, Any, Any]: ...
    @overload
    def __call__[K, V](self, ktype: type[K], vtype: type[V]) -> Struct[K, V, K, V]: ...

class Struct[K, V, K1, V1]:

    def __call__(self, value: dict[K, V]) -> dict[K1, V1]:...
    def map_keys[T](self, f: TransformFunc[K, T]) -> "Struct[K, V, T, V1]": ...
    def map_values[T](self, f: TransformFunc[V, T]) -> "Struct[K, V1, K1, T]": ...
    def select(self, predicate: CheckFunc[K]) -> Self: ...
    def filter(self, predicate: CheckFunc[V]) -> Self: ...
    def filter_on_key(self, key: K, predicate: CheckFunc[V]) -> Self: ...
    def with_key(self, key: K, value: V) -> Self: ...
    def with_nested_key(self, keys: Iterable[K] | K, value: V) -> Self: ...
    def update_in(self, *keys: K, f: ProcessFunc[V]) -> Self: ...
    def merge(self, *others: dict[K, V]) -> Self: ...
    def merge_with(
        self, f: Callable[[Iterable[V]], V], *others: dict[K, V]
    ) -> Self: ...
    def drop(self, *keys: K) -> Self: ...
    def flatten_keys(self) -> "Struct[K, V, str, V1]": ...
    def to_obj[T](self, obj: Callable[[dict[K, V]], T]) -> T: ...
