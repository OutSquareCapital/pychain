from collections.abc import Callable, Container
from typing import Any, Literal

class ChainableOp[T]:
    """
    Enables method chaining for functional-style operations on data.
    """
    _pipeline: Callable[[Any], T]
    def __init__(self, pipeline: Callable[[Any], T] | None = None) -> None: ...
    def __call__(self, value: Any) -> T:
        """
        Applies the chainable operation to the input value.

        Example:
            >>> ChainableOp(lambda x: x + 1)(2)
            3
        """
        ...
    def _chain[U](self, new_op: Callable[[T], U]) -> "ChainableOp[U]": ...
    def attr(self, name: str) -> "ChainableOp[T]":
        """
        Accesses the named attribute of the input object.

        Example:
            >>> ChainableOp(lambda x: x).attr('real')(3.5)
            3.5
        """
        ...
    def hint[U](self, dtype: U) -> "ChainableOp[U]": ...
    def item(self, key: str) -> "ChainableOp[T]":
        """
        Accesses the item with the given key from the input object.

        Example:
            >>> ChainableOp(lambda x: x).item('a')({'a': 42})
            42
        """
        ...
    def add(self, value: T) -> "ChainableOp[T]":
        """
        Adds the given value to the input.

        Example:
            >>> ChainableOp(lambda x: x).add(2)(3)
            5
        """
        ...
    def sub(self, value: T) -> "ChainableOp[T]": ...
    def mul(self, value: T) -> "ChainableOp[T]": ...
    def truediv(self, value: T) -> "ChainableOp[T]": ...
    def floordiv(self, value: T) -> "ChainableOp[T]": ...
    def sub_r(self, value: T) -> "ChainableOp[T]": ...
    def truediv_r(self, value: T) -> "ChainableOp[T]": ...
    def floordiv_r(self, value: T) -> "ChainableOp[T]": ...
    def mod(self, value: T) -> "ChainableOp[T]": ...
    def pow(self, value: T) -> "ChainableOp[T]": ...
    def neg(self) -> "ChainableOp[T]": ...
    def round_to(self, ndigits: int) -> "ChainableOp[float]": ...
    def is_true(self) -> "ChainableOp[bool]": ...
    def is_none(self) -> "ChainableOp[bool]": ...
    def is_not_none(self) -> "ChainableOp[bool]": ...
    def is_in(self, values: Container[T]) -> "ChainableOp[bool]": ...
    def is_not_in(self, values: Container[T]) -> "ChainableOp[bool]": ...
    def is_distinct(self) -> "ChainableOp[bool]": ...
    def is_iterable(self) -> "ChainableOp[bool]": ...
    def is_all(self) -> "ChainableOp[bool]": ...
    def is_any(self) -> "ChainableOp[bool]": ...
    def eq(self, value: T) -> "ChainableOp[bool]": ...
    def ne(self, value: T) -> "ChainableOp[bool]": ...
    def gt(self, value: T) -> "ChainableOp[bool]": ...
    def ge(self, value: T) -> "ChainableOp[bool]": ...
    def lt(self, value: T) -> "ChainableOp[bool]": ...
    def le(self, value: T) -> "ChainableOp[bool]": ...
    def mean(self) -> "ChainableOp[float]": ...
    def median(self) -> "ChainableOp[float]": ...
    def mode(self) -> "ChainableOp[Any]": ...
    def stdev(self) -> "ChainableOp[float]": ...
    def variance(self) -> "ChainableOp[float]": ...
    def pvariance(self) -> "ChainableOp[float]": ...
    def median_low(self) -> "ChainableOp[float]": ...
    def median_high(self) -> "ChainableOp[float]": ...
    def median_grouped(self) -> "ChainableOp[float]": ...
    def quantiles(self, n: int, method: Literal["inclusive", "exclusive"]) -> "ChainableOp[float]": ...
    def min(self) -> "ChainableOp[T]": ...
    def max(self) -> "ChainableOp[T]": ...
    def sum(self) -> "ChainableOp[T]": ...

class OpConstructor:
    """
    Constructs chainable operations for functional-style data processing.
    """
    def __call__(self, name: str) -> ChainableOp[Any]: ...
    def item(self, value:Any) -> ChainableOp[Any]: ...
    def add[T](self, value: T) -> ChainableOp[T]: ...
    def sub[T](self, value: T) -> ChainableOp[T]: ...
    def mul[T](self, value: T) -> ChainableOp[T]: ...
    def truediv[T](self, value: T) -> ChainableOp[T]: ...
    def floordiv[T](self, value: T) -> ChainableOp[T]: ...
    def sub_r[T](self, value: T) -> ChainableOp[T]: ...
    def truediv_r[T](self, value: T) -> ChainableOp[T]: ...
    def floordiv_r[T](self, value: T) -> ChainableOp[T]: ...
    def mod[T](self, value: T) -> ChainableOp[T]: ...
    def pow[T](self, value: T) -> ChainableOp[T]: ...
    def neg(self) -> ChainableOp[Any]: ...
    def round_to(self, ndigits: int) -> ChainableOp[float]: ...
    def is_true(self) -> ChainableOp[bool]: ...
    def is_none(self) -> ChainableOp[bool]: ...
    def is_not_none(self) -> ChainableOp[bool]: ...
    def is_in[T](self, values: Container[T]) -> ChainableOp[bool]: ...
    def is_not_in[T](self, values: Container[T]) -> ChainableOp[bool]: ...
    def is_distinct(self) -> ChainableOp[bool]: ...
    def is_iterable(self) -> ChainableOp[bool]: ...
    def is_all(self) -> ChainableOp[bool]: ...
    def is_any(self) -> ChainableOp[bool]: ...
    def eq(self, value: Any) -> ChainableOp[bool]: ...
    def ne(self, value: Any) -> ChainableOp[bool]: ...
    def gt(self, value: Any) -> ChainableOp[bool]: ...
    def ge(self, value: Any) -> ChainableOp[bool]: ...
    def lt(self, value: Any) -> ChainableOp[bool]: ...
    def le(self, value: Any) -> ChainableOp[bool]: ...
    def mean(self) -> ChainableOp[float]: ...
    def median(self) -> ChainableOp[float]: ...
    def mode(self) -> ChainableOp[Any]: ...
    def stdev(self) -> ChainableOp[float]: ...
    def variance(self) -> ChainableOp[float]: ...
    def pvariance(self) -> ChainableOp[float]: ...
    def median_low(self) -> ChainableOp[float]: ...
    def median_high(self) -> ChainableOp[float]: ...
    def median_grouped(self) -> ChainableOp[float]: ...
    def quantiles(self, n: int, method: Literal["inclusive", "exclusive"]
    ) -> ChainableOp[float]: ...
    def min(self) -> ChainableOp[Any]: ...
    def max(self) -> ChainableOp[Any]: ...
    def sum(self) -> ChainableOp[Any]: ...
