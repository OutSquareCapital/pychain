import ast
import hashlib
import inspect
import textwrap
from dataclasses import dataclass, field
from pathlib import Path
from typing import Any, Self

from ._ast_parsers import (
    FunctionDefFinder,
    TypedLambda,
    add_cfunc,
    create_type_node,
    get_callable_ast,
    match_node,
)
from ._enums import Names
from ._protocols import Func, Scope, SignaturesRegistery


@dataclass(slots=True)
class SourceCode:
    code: str
    func_name: str

    def __repr__(self) -> str:
        indented_code: str = textwrap.indent(self.code, "    ")
        return f"pychain\n-- Source --\n{indented_code}"

    def as_tree(self) -> ast.Module:
        return ast.parse(self.code)

    def clean_aliases(self, alias_map: dict[str, str]):
        for alias, real_name in alias_map.items():
            self.code = self.code.replace(alias, real_name)
        return self

    def get_hash(self) -> str:
        return hashlib.sha256(self.code.encode("utf-8")).hexdigest()

    def write_to_file(self, path: Path) -> None:
        path.write_text(self.code, encoding="utf-8")

    def add_cython_decorators(self) -> Self:
        tree = self.as_tree()
        if isinstance(tree.body[0], ast.FunctionDef):
            decorator = ast.Name(id=Names.CCALL.value, ctx=ast.Load())
            tree.body[0].decorator_list.insert(0, decorator)
            self.code = ast.unparse(tree)
        return self

    def finalize(self, import_section: str, dependencies_section: str):
        file_content = f"{import_section}\n\n{dependencies_section}\n\n{self.code}"
        self.code = f"# Generated by pychain\n# type: ignore\n{file_content}"
        return self


@dataclass(slots=True)
class ModuleBuilder:
    signatures: SignaturesRegistery
    imports: set[str] = field(default_factory=set[str])
    definitions: dict[int, str] = field(default_factory=dict[int, str])
    processed_ids: set[int] = field(default_factory=set[int])
    alias_map: dict[str, str] = field(default_factory=dict[str, str])

    def generate(self, source: SourceCode, scope: Scope):
        self._gather_dependencies(scope)
        return (
            source.clean_aliases(self.alias_map)
            .add_cython_decorators()
            .finalize(self.import_section, self.dependencies_section)
        )

    def _add_import(self, name: str) -> None:
        self.imports.add(f"import {name}")

    def _add_func_dependency(self, func_obj: Func[Any, Any], ref_name: str) -> Self:
        tree = ast.parse(func_obj.source_code)
        finder = FunctionDefFinder()
        finder.visit(tree)
        if func_def := finder.found_func:
            decorator = ast.Name(id=Names.CFUNC.value, ctx=ast.Load())
            func_def.decorator_list.insert(0, decorator)
            self._add_type_annotations(func_def, id(func_obj.func))
            self.definitions[id(func_obj)] = ast.unparse(func_def)
            self.alias_map[ref_name] = func_def.name

        return self

    def _add_func(
        self, node: ast.FunctionDef | ast.Lambda, name: str, obj_id: int
    ) -> None:
        if func_def := match_node(node, name):
            self._add_type_annotations(func_def, obj_id).definitions[obj_id] = (
                add_cfunc(func_def)
            )

    def _add_type_annotations(self, func_def: ast.FunctionDef, obj_id: int) -> Self:
        if not (signature := self.signatures.get(obj_id)):
            return self
        for arg in func_def.args.args:
            if arg_type := signature.params.get(arg.arg):
                if type_node := create_type_node(self.imports, arg_type):
                    arg.annotation = type_node
        if type_node := create_type_node(self.imports, signature.return_type):
            func_def.returns = type_node

        return self

    @property
    def import_section(self) -> str:
        all_imports = self.imports.copy()
        all_imports.add("import cython")
        return "# --- Imports ---\n" + "\n".join(sorted(list(all_imports)))

    @property
    def dependencies_section(self) -> str:
        return "# --- Dependencies ---\n" + "\n\n".join(self.definitions.values())

    def _gather_dependencies(self, scope: Scope) -> Self:
        for name, obj in scope.items():
            if TypedLambda.identity(obj):
                obj = obj.func

            obj_id = id(obj)
            if obj_id in self.processed_ids or name.startswith(Names.PC_FUNC_.value):
                continue
            self.processed_ids.add(obj_id)

            if isinstance(obj, Func):
                self._add_func_dependency(obj, name)._gather_dependencies(obj.scope)  # type: ignore
                continue

            if inspect.ismodule(obj):
                self._add_import(obj.__name__)
                continue

            if not (inspect.isfunction(obj) or inspect.isclass(obj)):
                continue

            module = inspect.getmodule(obj)
            if module and module.__name__ == "__main__":
                if node := get_callable_ast(obj):
                    self._add_func(node, name, obj_id)
            elif module:
                self._add_import(module.__name__)

        return self
